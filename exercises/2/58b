(load "deriv.scm")

;; Put in a list if it's not a list.
(define (listify x)
  (if (list? x) x (list x)))

(assert (equal? '(1) (listify 1)))
(assert (equal? '(1) (listify '(1))))
(assert (equal? '(1 2) (listify '(1 2))))

;; Take out of a list if it's only one element, otherwise do nothing.
(define (delistify l)
    (if (= (length l) 1)
        (car l)
        l))

(assert (equal? 1 (delistify '(1))))
(assert (equal? '(1 2) (delistify '(1 2))))

(define (sum? x)
  (if (and (list? x) (memq '+ x)) #t #f))

(assert (sum? '(1 + 2)))
(assert (sum? '(1 + 2 + 3)))
(assert (sum? '(1 * 2 + 3)))
(assert (sum? '(1 + 2 * 3)))
(assert (sum? '(1 + 2 * (3 + 4))))
(assert (not (sum? 1)))
(assert (not (sum? '(1 * 2))))
(assert (not (sum? '(1 * (2 + 3)))))
(assert (not (sum? '((1 + 2) * 3))))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (append (listify a1) '(+) (listify a2)))))

(assert (equal? 'x (make-sum 0 'x)))
(assert (equal? 'x (make-sum 'x 0)))
(assert (equal? 3 (make-sum 1 2)))
(assert (equal? '(1 + x) (make-sum 1 'x)))
(assert (equal? '(1 + 2 + 3) (make-sum 1 '(2 + 3))))
(assert (equal? '(1 + 2 + 3) (make-sum '(1 + 2) 3)))
(assert (equal? '(1 * 2 + 3 + 4) (make-sum '(1 * 2) '(3 + 4))))

(define (addend s)
  (define (iter s)
    (cond ((not (list? s)) '())
          ((eq? (car s) '+) '())
          (else (cons (car s)
                      (iter (cdr s))))))
  (delistify (iter s)))

(assert (equal? 1 (addend '(1 + 2))))
(assert (equal? 1 (addend '(1 + 2 + 3))))
(assert (equal? 1 (addend '(1 + 2 * 3))))
(assert (equal? '(1 * 2) (addend '(1 * 2 + 3))))
(assert (equal? '(1 * 2 * x) (addend '(1 * 2 * x + 3))))

(define (augend s)
  (delistify (cdr (memq '+ s))))

(assert (equal? 2 (augend '(1 + 2))))
(assert (equal? '(2 + 3) (augend '(1 + 2 + 3))))
(assert (equal? '(2 * 3) (augend '(1 + 2 * 3))))
(assert (equal? 3 (augend '(1 * 2 + 3))))

(define (make-product m1 m2)
  (cond ((=number? m1 0) 0)
        ((=number? m2 0) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2))
         (* m1 m2))
        ((and (sum? m1) (sum? m2))
         (append (list m1) '(*) (list m2)))
        ((sum? m1)
         (append (list m1) '(*) (listify m2)))
        ((sum? m2)
         (append (listify m1) '(*) (list m2)))
        (else (append (listify m1) '(*) (listify m2)))))

(assert (equal? 0 (make-product 0 'x)))
(assert (equal? 0 (make-product 'x 0)))
(assert (equal? 'x (make-product 1 'x)))
(assert (equal? 'x (make-product 'x 1)))
(assert (equal? 6 (make-product 2 3)))
(assert (equal? '(2 * x) (make-product 2 'x)))
(assert (equal? '(4 * 2 * 3) (make-product 4 '(2 * 3))))
(assert (equal? '(4 * 2 * 3) (make-product '(4 * 2) 3)))
(assert (equal? '((1 + 2) * 3 * 4) (make-product '(1 + 2) '(3 * 4))))
(assert (equal? '(5 * 2 * (3 + 4)) (make-product '(5 * 2) '(3 + 4))))

(define (product? x)
  (if (and (list? x)
           (memq '* x)
           (not (memq '+ x)))
      #t
      #f))

(assert (product? '(1 * 2)))
(assert (product? '(1 * (2 + 3))))
(assert (product? '((1 + 2) * 3)))
(assert (product? '(1 * 2 * 3)))
(assert (not (product? 1)))
(assert (not (product? '(1 + 2))))
(assert (not (product? '(1 + 2 * 3))))
(assert (not (product? '(1 * 2 + 3))))

(define (multiplier p)
  (define (iter p)
    (cond ((not (list? p)) '())
          ((eq? (car p) '*) '())
          (else (cons (car p)
                      (iter (cdr p))))))
  (delistify (iter p)))

(assert (equal? 1 (multiplier '(1 * 2))))
(assert (equal? 1 (multiplier '(1 * 2 * 3))))
(assert (equal? 1 (multiplier '(1 * (2 + 3)))))
(assert (equal? '(1 + 2) (multiplier '((1 + 2) * 3))))

(define (multiplicand p)
  (delistify (cdr (memq '* p))))

(assert (equal? 2 (multiplicand '(1 * 2))))
(assert (equal? '(2 * 3) (multiplicand '(1 * 2 * 3))))
(assert (equal? '(2 + 3) (multiplicand '(1 * (2 + 3)))))
(assert (equal? 3 (multiplicand '((1 + 2) * 3))))

(assert (equal? 4 (deriv '(x + 3 * (x + y + 2)) 'x)))
