(define (fast-mul-interval x y)
  (let ((lx (lower-bound x))
        (ux (upper-bound x))
        (ly (lower-bound y))
        (uy (upper-bound y)))
    (cond ((and (> 0 lx) (> 0 ux) (> 0 ly) (> 0 uy))
           (make-interval (* ux uy) (* lx ly)))
          ((and (> 0 lx) (> 0 ux) (> 0 ly))
           (make-interval (* lx uy) (* lx ly)))
          ((and (> 0 lx) (> 0 ux))
           (make-interval (* lx uy) (* ux ly)))
          ((and (> 0 lx) (> 0 ly) (> 0 uy))
           (make-interval (* ux ly) (* lx ly)))
          ((and (> 0 lx) (> 0 ly))
           (let ((l1 (* lx uy))
                 (l2 (* ux ly))
                 (u1 (* lx ly))
                 (u2 (* ux uy)))
             (make-interval (min l1 l2) (max u1 u2))))
          ((> 0 lx)
           (make-interval (* lx uy) (* ux uy)))
          ((and (> 0 ly) (> 0 uy))
           (make-interval (* ux ly) (* lx uy)))
          ((> 0 ly)
           (make-interval (* ux ly) (* ux uy)))
          (else
           (make-interval (* lx ly) (* ux uy))))))

(define (eq-interval? x y)
  (and (= (lower-bound x) (lower-bound y))
       (= (upper-bound x) (upper-bound y))))

(define (test x y)
  (let ((mul (mul-interval x y))
        (fast-mul (fast-mul-interval x y)))
    (if (eq-interval? mul fast-mul)
        true
        (let () (display mul) (display fast-mul) false))))


(and (test (make-interval 2 3) (make-interval 4 5))
     (test (make-interval 2 3) (make-interval -4 5))
     (test (make-interval 2 3) (make-interval -5 -4))
     (test (make-interval -2 3) (make-interval 4 5))
     (test (make-interval -2 3) (make-interval -4 5))
     (test (make-interval -4 3) (make-interval -4 5))
     (test (make-interval -2 3) (make-interval -5 -4))
     (test (make-interval -3 -2) (make-interval 4 5))
     (test (make-interval -3 -2) (make-interval -4 5))
     (test (make-interval -3 -2) (make-interval -5 -4)))